<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <style>
    body {
      display: flex;
      margin: 0;
      font-family: Arial, sans-serif;
      height: 100vh;
      overflow: hidden;
    }

    .docs-article-container {
      display: flex;
      flex: 1;
      width: 100%;
      height: 100vh;
    }

    .text-container {
      flex: 1;  /* Занимает половину экрана */
      overflow-y: auto;
      padding: 1rem;
      background-color: #f9f9f9;
      box-sizing: border-box;
    }

    .link-container {
      flex: 1;  /* Занимает вторую половину экрана */
      background-color: #e9e9e9;
      box-shadow: -2px 0 5px rgba(0, 0, 0, 0.1);
      display: flex;
      flex-direction: column;
    }

    .link-container h2 {
      padding: 20px;
      margin: 0;
      background-color: #ddd;
      text-align: center;
    }

    .link-container iframe {
      flex: 1;
      border: none;
    }

    h1, h2, h3, h4 {
      color: #333;
    }

    a {
      color: #007bff;
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    img {
      max-width: 100%;
      height: auto;
    }
  </style>
</head>

<meta name="author" content="Администрирование Astra Linux">
<meta name="description" content="Learn how to use Academic&#39;s docs layout for publishing online courses, software documentation, and tutorials.">
<link rel="alternate" hreflang="en-us" href="/projects/example/">
<meta name="theme-color" content="#2962ff">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.6/css/academicons.min.css" integrity="sha256-uFVgMKfistnJAfoCUQigIl+JfUaP47GrRKjf6CTPVmw=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-1/css/all.min.css" integrity="sha256-4w9DunooKSr3MFXHXWyFER38WmPdm361bQS/2KUWZbU=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin="anonymous" title="hl-light">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/dracula.min.css" crossorigin="anonymous" title="hl-dark" disabled>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.5.1/leaflet.css" integrity="sha256-SHMGCYmST46SoyGgo4YR/9AlK1vf3ff84Aq9yK4hdqM=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.1.2/lazysizes.min.js" integrity="sha256-Md1qLToewPeKjfAHU1zyPwOutccPAm5tahnaw7Osw0A=" crossorigin="anonymous" async></script>

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat:400,700%7CRoboto:400,400italic,700%7CRoboto+Mono&display=swap">
<link rel="stylesheet" href="/css/academic.css">

<link rel="alternate" href="/projects/example/index.xml" type="application/rss+xml" title="Администрирование Astra Linux">
<link rel="manifest" href="/index.webmanifest">
<link rel="icon" type="image/png" href="/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_32x32_fill_lanczos_center_3.png">
<link rel="apple-touch-icon" type="image/png" href="/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_192x192_fill_lanczos_center_3.png">
<link rel="canonical" href="/projects/example/">



  <title>Лабораторные работы | Администрирование Astra Linux</title>

</head>

<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" >

  <aside class="search-results" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>Search</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="Search..." autocapitalize="off"
        autocomplete="off" autocorrect="off" spellcheck="false" type="search">
        
      </div>

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>
<meta property="twitter:card" content="summary">
<meta property="twitter:site" content="@timofeysamsonov">
<meta property="twitter:creator" content="@timofeysamsonov">
<meta property="og:site_name" content="Администрирование Astra Linux">
<meta property="og:url" content="/projects/example/">
<meta property="og:title" content="Лабораторная работа #1 | Введение в ОС Astra Linux 1.7. Использование справочных ресурсов.">
<meta property="og:description" content="Learn how to use Academic&#39;s docs layout for publishing online courses, software documentation, and tutorials.">
<meta property="og:image" content="/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_3.png">
<meta property="twitter:image" content="/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_3.png">
<meta property="og:locale" content="en-us">
<meta property="og:updated_time" content="2018-09-09T00:00:00+00:00">

<title>Лабораторные работы | Администрирование Astra Linux</title>

</head>

<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents">

<aside class="search-results" id="search">
  <div class="container">
    <section class="search-header">
      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>Search</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>
      <div id="search-box">
        <input name="q" id="search-query" placeholder="Search..." autocapitalize="off" autocomplete="off" autocorrect="off" spellcheck="false" type="search">
      </div>
    </section>
    <section class="section-search-results">
      <div id="search-hits"></div>
    </section>
  </div>
</aside>

<nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id="navbar-main">
  <div class="container">
    <div class="d-none d-lg-inline-flex">
      <a class="navbar-brand" href="/">Администрирование Astra Linux</a>
    </div>
    <button type="button" class="navbar-toggler" data-toggle="collapse"
            data-target="#navbar-content" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
    <span><i class="fas fa-bars"></i></span>
    </button>
    <div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none">
      <a class="navbar-brand" href="/">Администрирование Astra Linux</a>
    </div>
    <div class="navbar-collapse main-menu-item collapse justify-content-start" id="navbar-content">
      <ul class="navbar-nav d-md-inline-flex">
        <li class="nav-item">
          <a class="nav-link " href="/courses/"><span>Теоретический материал</span></a>
        </li>
        <li class="nav-item">
          <a class="nav-link " href="/projects/"><span>Лабораторные работы</span></a>
        </li>
        <li class="nav-item">
          <a class="nav-link " href="/about/"><span>Информационный блок</span></a>
        </li>
        <li class="nav-item">
          <a class="nav-link " href="/control/"><span>Итоговый контроль</span></a>
        </li>
        <li class="nav-item">
          <a class="nav-link " href="/ai/"><span>Побеседовать с виртуальным учителем</span></a>
        </li>
      </ul>
    </div>
  </div>
</nav>

 
   
  
</nav>

<div class="link-container">
  <h2>

    Консоль сервера

  </h2>
  <iframe 
    src="https://rsvpu.hackatom.ru:3000/" 
    style="border:0px; width:100%; height:100%;">
  </iframe>
</div>


    <article class="article">
      <div class="docs-article-container">
        <h1>
 
        </h1>
        <div class="text-container">
            <div class="article-style">
            <h2 id="flexibility">Лабораторная работа №5. Тема: "Управление устройствами и модулями ядра"</h2>

            <strong><p><---- Обратите внимание на консольный сервер в левой части экрана, вам следует использовать этот сервер для выполнения лабораторной работы</p></strong>
    
            <h2 id="flexibility">Цель работы</h2>
            <ul>
              <li>Изучить основные концепции и методы управления устройствами и модулями ядра в Astra Linux;</li>
              <li>Провести практические эксперименты с модулями ядра и устройствами в Astra Linux.</li>
          </ul>
      
          <h2>Оборудование, ПО:</h2>
          <p>Виртуальная машина или компьютер под управлением ОС AstraLinux 1.7 в режиме защищенности "Воронеж" или выше, а также с неразмеченной областью памяти на диске.</p>
          <p>Если работаете на виртуальной машине, просто добавьте ей дополнительный виртуальный диск объемом, как минимум в 1 гб.</p>
      
          <h2>Ход работы:</h2>
      
          <h3>Начнем с терминологии.</h3>
          <p>Ядро - это часть операционной системы, которая работает скрытно от пользователя системы, ведь пользователь не работает с ядром напрямую - он взаимодействует с программами и редакторами т.д.</p>
          <p>Ядро берет на себя задачу обеспечить работу той или иной программы. Ядро имеет доступ к аппаратной части компьютера (к процессору, оперативной памяти, устройству хранения и т.д.).</p>
      
          <img src="./Screen1.png" alt="Картинка">
      
          <p>Стоит напомнить, что в Linux все драйвера и аппаратные подсистемы работают в одном адресном пространстве. Вы можете загружать и выгружать модули ядра для расширения функционала вашей операционной системы.</p>
          <p>Чаще всего в процессе работы необходимо подключать модули драйверов устройств, поддержки криптографических алгоритмов, сетевых средств, и, чтобы уметь это правильно делать, нужно разбираться в строении ядра и уметь правильно работать с его модулями. Об этом и пойдет речь в этой лабораторной работе.</p>
          <p>Процесс автоматической загрузки нового модуля ядра (при его наличии, конечно) во время подключения нового устройства выполняет демон - udev.</p>
      
          <h3>Доступные модули хранятся в каталогах:</h3>
          <ul>
              <li><strong>/lib/modules/&lt;ядро_вашей_ос&gt;</strong> в виде файлов с расширением "ko".</li>
              <li><strong>/lib32/modules/&lt;ядро_вашей_ос&gt;</strong> в случае, если модуль ядра для х32-битной архитектуры.</li>
              <li><strong>/lib64/modules/&lt;ядро_вашей_ос&gt;</strong> в случае, если модуль ядра для х64-битной архитектуры.</li>
          </ul>
      
          <img src="./Screen2.png" alt="Картинка">
      
          <p>Стоит сразу предупредить, что вам не придется искать модули ядра в разных каталогах. Если модуль уже присутствует в каталоге /lib/modules, то в других каталогах на него будет создана символьная ссылка, для оперативного доступа и взаимодействия.</p>
      
          <img src="./Screen3.png" alt="Картинка">
      
          <h3>Поиск модулей ядра</h3>
          <p>Попробуем найти модули ядра, что установлены на компьютере под AstraLinux 1.7:</p>
          <pre><code>find /lib/modules/`uname -r` -name "*.ko"</code></pre>
          <p>Поясним введённую команду:</p>
          <p>С поиском вы уже знакомы, но как можно заметить, в команде поиска мы непосредественно обращаемся к выводу другой команды - <strong>uname -r</strong>. Данная команда выведет в ответ версию ядра вашей операционной системы, заключая конструкцию в ` ` вывод команды будет "дополнен" в find.</p>
      
          <img src="./Screen4.png" alt="Картинка">
      
          <p>Файловая структура модулей выполнена по названию службы, за которую она отвечает. Как видно на примере, директория sound отвечает за модули ядра звуковой карты, а каталог firewire, за поддержку стандарта IEEE 1394.</p>
      
          <h3>Команда modinfo</h3>
          <p>Давайте воспользуемся командой 'modinfo', чтобы вывести более подробную информацию о модуле.</p>
          <p>Шаблон применения:</p>
          <pre><code>sudo modinfo &lt;название_ядра&gt;</code></pre>
          <p>Например, давайте выведем информацию о библиотеке snd-firewire-lib.</p>
          <pre><code>sudo modinfo snd-firewire-lib</code></pre>
      
          <img src="./Screen5.png" alt="Картинка">
      
          <p>Вывод команды указывает нам версию модуля ядра, его автора (поле author), зависимости установки (поле depends), сведения о версии и т.д.</p>
          <p>Сравним вывод с другой командой:</p>
          <pre><code>sudo modinfo rt73usb</code></pre>
          <p>Как можно заметить, вывод команды огромен. Давайте ограничим его с помощью известной нам команды <strong>head</strong>:</p>
          <pre><code>sudo modinfo rt73usb | head</code></pre>
      
          <img src="./Screen6.png" alt="Картинка">
      
          <p>Обратите внимание, что появилась строка firmware.</p>
      
          <h3>Поле «firmware»</h3>
          <p>Поле «firmware» указывает на то, что этот модуль сам по себе не работает, ему нужна бинарная микропрограмма устройства в специальном файле «rt73.bin». Необходимость в файле микропрограммы появилась в связи с тем, что интерфейс взаимодействия с устройством закрыт, и эти функции возложены на файл прошивки (firmware). Взять firmware можно с сайта разработчика, установочного диска, поставляемого вместе с устройством, или где-нибудь в репозиториях дистрибутива, затем нужно его скопировать в каталог "/lib/firmware", при чем имя файла должно совпадать с тем, что указано в модуле.</p>
      
          <h3>Загрузка модуля ядра</h3>
          <p>Загрузить модуль ядра можно с помощью команд - "insmod" и "modprobe". Команда «insmod» загружает конкретный файл с расширением «*.ko», при этом, если модуль зависит от других модулей, еще не загруженных в ядро, команда выдаст ошибку, и не загрузит модуль. Команда «modprobe» работает только с деревом модулей, и возможна загрузка только оттуда по имени модуля, а не по имени файла. Отсюда следует область применения этих команд: при помощи «insmod» подгружается файл модуля из произвольного места файловой системы (например, пользователь скомпилировал модули и перед переносом в дерево ядра решил проверить его работоспособность), а «modprobe» — для подгрузки уже готовых модулей, включенных в дерево модулей текущей версии ядра.</p>
          <p>Например, чтобы выполнить загрузку ядра можно ввести команду:</p>
          <pre><code>sudo modprobe rt73usb</code></pre>
      
          <img src="./Screen7.png" alt="Картинка">
      
          <p>В большинстве дистрибутивов этого было бы достаточно, но в Astra Linux также необходимо добавить желаемый модуль ядра в файл - <strong>/etc/modules-load.d/modules.conf</strong>.</p>
          <p>Примечания - также стоит проверить, что данный модуль не противоречит политикам ИБ в Astra Linux и не заблокирован в файле <strong>/etc/modprobe.d/blacklist.conf</strong>.</p>
      
          <img src="./Screen8.png" alt="Картинка">
      
          <p>После этого выполните перезагрузку. После загрузки компьютера выполните команду:</p>
          <pre><code>sudo lsmod | grep rt73usb</code></pre>
      
          <img src="./Screen9.png" alt="Картинка">
      
          <p>Модуль успешно подгрузился! Теперь, если у нас в компьютере появится адаптер беспроводной связи Ralink, то он корректно будет работать на нашем устройстве.</p>
      
          <h3>Выгрузка модуля</h3>
          <p>Просто удалите строчку с вашем модулем из файла - <strong>/etc/modules-load.d/modules.conf</strong> и выполните перезагрузку. После выгрузки модуля все возможности, которые он предоставлял, будут удалены из таблицы ядра. Выполните проверку удаления модуля ядра самостоятельно.</p>
      
          <h2>Управление устройствами в Astra Linux</h2>
          <p>При работе с Linux, вы наверняка слышали крылатую фразу - "В Linux - всё есть файл". И это правда! Даже подключенные в систему клавиатура или мышь, процесс и ваш жесткий диск имеют абстрактный файл в системе.</p>
          <p>Докажем данную гипотезу и заглянем в каталог /dev/:</p>
          <pre><code>ls /dev/</code></pre>
      
          <img src="./Screen10.png" alt="Картинка">
      
          <p>Огромное множество разных файлов вы видите перед собой - это все устройства (виртуальные или физические), которые используются в вашем компьютере.</p>
          <p>Первый символ c в первой колонке указывает на тип файла — в данном случае символьное устройство. Для обычных файлов используется символ «-» (дефис), для каталогов — d, для блочных устройств — b.</p>
          <p>Например, обратите внимание на файл <strong>/dev/core</strong>. Попробуем его открыть?</p>
          <pre><code>sudo cat /dev/core</code></pre>
      
          <img src="./Screen11.png" alt="Картинка">
      
          <p>Нажмите Ctrl + C, чтобы отменить просмотр документа - он никогда не будет выведен полностью, ведь информация постоянно поступает в этот файл.</p>
          <p>Этот файл отображает физическую память системы и записывается в ELF формате файла core. Полная длина этого файла - это размер оперативной памяти (RAM) плюс 4KB. С помощью этого псевдо-файла можно отслеживать текущее состояние любых структур ядра.</p>
          <p>Наличие файлов устройств не означает, что данные устройства установлены в системе. Например, наличие файла <strong>/dev/sda</strong> не означает, что на компьютере установлен жесткий диск SCSI. Это предусмотрено для облегчения установки программ и нового оборудования, т.к. исключает необходимость поиска нужных параметры и создания файлов для новых устройств.</p>
          <p>Каждый жесткий диск представлен отдельным файлом устройства в каталоге /dev: <strong>/dev/hda</strong> и <strong>/dev/hdb</strong> для первого и второго диска, подключенного по IDE шине, и <strong>/dev/sda</strong>, <strong>/dev/sdb</strong> и т. д. для дисков, использующих SCSI или SATA-интерфейс.</p>
          <p>Стоит также упомянть, что в ядро ОС встроена программная реализация технологии RAID (уровни: RAID 0, RAID 1, RAID 5 и их сочетания). Команда <strong>mdadm</strong> предоставляет административный интерфейс пользователя для создания и управления массивами. После создания массива его устройство, например, <strong>/dev/md0</strong>, используется точно также, как <strong>/dev/hda1</strong> или <strong>/dev/sdb7</strong>.</p>
      
          <h3>Работа с блочными устройствами</h3>
          <p>Очевидно, что в случае с блочными устройствами вы можете:</p>
          <ol>
              <li>Установить на них файловую систему.</li>
              <li>Примонтировать пространство памяти в каталог в ОС (например, в /home - для хранения домашних профилей пользователей).</li>
              <li>Аналогично приходится выполнять процедуру и размонтирования.</li>
          </ol>
      
          <h4>Инструменты для установки файловой системы:</h4>
          <ul>
              <li>Консольная утилита <strong>fdisk</strong>.</li>
              <li>Графическая утилита <strong>gparted</strong>.</li>
          </ul>
      
          <h4>Работа с fdisk</h4>
          <p>1) Если вы используете новое блочное устройство, а не раздел уже размеченного ранее диска, то выполните следующие шаги:</p>
          <ul>
              <li>Войдите в систему под пользователем с высоким уровнем целостности.</li>
              <li>Убедитесь, что в систему успешно добавлен новый диск:</li>
          </ul>
          <pre><code>lsblk</code></pre>
      
          <img src="./Screen12.png" alt="Картинка">
      
          <p>Данная команда выводит список всех доступных блочных устройств, а также пути их монтирования в ОС.</p>
          <p>Как можно заметить, у нас присутствует блочный диск /dev/sdb, который не имеет раздела.</p>
          <p>Почему мы сделали такой поспешный вывод?</p>
          <p><strong>При создании раздела на диске он будет пронумерован, то есть при создании первого раздела он получит наименование /dev/sdb1, при создании второго - /dev/sdb2 и т.д.</strong></p>
          <p>В подтверждение этих слов, обратите внимание на <strong>/dev/sda</strong> - каждый раздел пронумерован.</p>
          <p>Перейдем к форматированию нашего диска:</p>
          <pre><code>sudo fdisk /dev/sdb</code></pre>
      
          <img src="./Screen13.png" alt="Картинка">
      
          <p>Первым делом научимся обращаться к встроенной справке - введите букву "m".</p>
      
          <img src="./Screen14.png" alt="Картинка">
      
          <p>В Astra Linux данный инструмент управления дисками переведен на русский язык, так что им достаточно удобно пользоваться. Внимательно ознакомьтесь с выводом команды!</p>
          <p>Создадим новую таблицу разделов на диске с помощью команды - 'o'.</p>
      
          <img src="./Screen15.png" alt="Картинка">
      
          <p>После создания таблицы разделов, создадим сам раздел и разметим его, введите команду - "n".</p>
      
          <img src="./Screen16.png" alt="Картинка">
      
          <p>После этого, необходимо выбрать тип раздела - основной или расширенный. Расширенный вам понадобится в случаях, если потребуется добавлять данный диск в RAID или LVM массивы. Выбираем - "p", а затем "1", чтобы у нашего раздела был первый номер разметки.</p>
      
          <img src="./Screen17.png" alt="Картинка">
      
          <p>Далее система задаст вам вопрос, какой сектор диска занять первым, а какой последним - это можно интерпертировать, как объем физического пространства, который диск заполнит в свой раздел.</p>
          <p>Оставляя значения по умолчанию, всё доступное пространство будет использовано для этого раздела.</p>
          <p>Чтобы записать выполненные изменения, нажмите "w".</p>
      
          <img src="./Screen19.png" alt="Картинка">
      
          <p>А что если нам нужно было всего 500 мб?</p>
      
          <img src="./Screen18.png" alt="Картинка">
      
          <p>В этом случае, вам пришлось бы вручную назначть необходимый объем по формуле:</p>
          <pre><code>+ &lt;число&gt; и далее буква K, M, G что соответственно указывает на килобайты, мегабайты, гигабайты.</code></pre>
          <p>Проверим результат:</p>
      
          <img src="./Screen20.png" alt="Картинка">
      
          <p>Как можно заметить раздел был создан, объемом в 1 Гб. Теперь на нём необходимо создать файловую систему.</p>
          <p><strong>Файловая система — порядок, определяющий способ организации, хранения и именования данных на носителях информации в компьютерах.</strong></p>
          <p>Файловых систем, которые могут работать в Linux - огромное множество (не только EXT4, NTFS или FAT32), а их количество только увеличивается. Спорить о их приемуществах и качествах можно долго.</p>
          <p>Объединяет их одного - Linux сможет работать со всеми из них только если она будет установлена в ОС. Установка новой файловой системы ничем не отличается от установки любой программы на Astra Linux.</p>
          <p>Например, вам потребовалось установить кластерную файловую систему - GlusterFS. Введите команду:</p>
          <pre><code>sudo apt install glusterfs-common -y</code></pre>
          <p>И данная система будет на вашем ПК! Команду выше можно не вводить, она лишь примерна.</p>
          <p>Стоит уточнить, что далеко не все файловые системы поддерживает метки конфиденциальности и уровни целостности.</p>
          <p>Astra Linux Special Edition поддерживает работу с конфиденциальной информацией на дисковых разделах со следующими файловыми системами:</p>
          <ul>
              <li>ext2/ext3/ext4;</li>
              <li>xfs (начиная с Astra Linux Special Edition x.7);</li>
              <li>vfat;</li>
              <li>ntfs (поддерживается только полуавтоматическое монтирование в сессиях с нулевой классификационной меткой);</li>
              <li>iso9660/udf;</li>
          </ul>
          <p>Большинство файловых систем после установки в ОС можно сразу же разместить на ваш подготовленный диск через встроенный в систему набор скриптов - mkfs.</p>
      
          <img src="./Screen21.png" alt="Картинка">
      
          <p>Например, давайте установим на раздел /dev/sdb1 файловую систему EXT4.</p>
          <pre><code>sudo mkfs.ext4 /dev/sdb1</code></pre>
      
          <img src="./Screen22.png" alt="Картинка">
      
          <p>Отлично! Раздел на диске есть, файловая система также была удачно установлена. Мы готовы монтировать данный диск в каталог на нашем компьютере!</p>
          <pre><code>sudo mount /dev/sdb1 /opt</code></pre>
      
          <img src="./Screen23.png" alt="Картинка">
      
          <p>Проверить удачное монтирование можно с помощью команды:</p>
          <pre><code>df -h</code></pre>
      
          <img src="./Screen24.png" alt="Картинка">
      
          <p>Возьмите данную команду себе на заметку, она позволит вам быстро и удобно выяснить куда примонтирован тот или иной диск, а также доступное на нём место.</p>
          <p>Теперь, наш каталог /opt логически все также присутсвует в операционной системе, но физически размещен на другом диске.</p>
          <p>Попробуем в него сохранить файл?</p>
          <pre><code>cd /opt
      touch file</code></pre>
      
          <img src="./Screen25.png" alt="Картинка">
      
          <p>Вышла ошибка! Проверим, каки права указаны на каталог /opt:</p>
          <pre><code>ls -la /opt</code></pre>
      
          <img src="./Screen26.png" alt="Картинка">
      
          <p>Как можно заметить, правда совершенно не позволяют пользователям создавать файлы в каталоге. В рамках нашей работы, настроим права 777 - разрешим всем заходить и создавать файлы в этом каталоге.</p>
          <pre><code>sudo chmod 777 /opt</code></pre>
      
          <img src="./Screen27.png" alt="Картинка">
      
          <p>Теперь файлы создаются корректно!</p>
          <pre><code>cd /opt
      touch test
      ls</code></pre>
      
          <img src="./Screen28.png" alt="Картинка">
      
          <p>Казалось бы, что еще нужно - диск подключен и позволяет сохранять там файлы. Но мы не добавили это блочное устройство в параметры автомонтирования, за это отвечает файл <strong>/etc/fstab</strong>.</p>
          <p>Примечание - стоит уточнить, что сетевые ресурсы, доступ к которым динамически назначается через ваши доменные политики монтируется с помощью технологии libpam-mount и конфигурационного файла <strong>/etc/security/pam_mount.conf.xml</strong>.</p>
          <p>Для этого перейдем в файл <strong>/etc/fstab</strong> и добавим следующую строку:</p>
          <pre><code>/dev/sdb1 /opt ext4 defaults 0 0</code></pre>
      
          <img src="./Screen29.png" alt="Картинка">
      
          <p>Разберемся с указанной строкой:</p>
          <ul>
              <li><strong>/dev/sdb1</strong> - указываем диск, который планируется смонтировать.</li>
              <li><strong>/opt</strong> - указываем каталог для монтирования.</li>
              <li><strong>ext4</strong> - указываем файловую систему на монтируемом блочном устройстве.</li>
              <li><strong>defaults</strong> - Далее указываются опции монтирования.</li>
          </ul>
      
          <h4>Опции монтирования:</h4>
          <table>
              <tr>
                  <th>Общие опции</th>
                  <th>Описание</th>
              </tr>
              <tr>
                  <td>sync/async</td>
                  <td>Все операции ввода / вывода файловой системы должны выполняться синхронно/асинхронно.</td>
              </tr>
              <tr>
                  <td>atime</td>
                  <td>Производить запись времени последнего доступа к файлу. Значение по умолчанию.</td>
              </tr>
              <tr>
                  <td>noatime</td>
                  <td>Не обновлять время доступа к файлу (например, для быстрого доступа к потокам данных.</td>
              </tr>
              <tr>
                  <td>relatime</td>
                  <td>Обновлять время доступа только при изменении файла или изменении времени доступа. (В отличие от noatime, необходимая опция для нормальной работы, например, почтовых клиентов или других приложений, которым необходимо точное время последнего изменения файлов).</td>
              </tr>
              <tr>
                  <td>norelatime</td>
                  <td>Не включать функцию relatime.</td>
              </tr>
              <tr>
                  <td>strictatime</td>
                  <td>Обновление времени доступа к структуре данных при изменении файлов. Отключает noatime и relatime.</td>
              </tr>
              <tr>
                  <td>auto / noauto</td>
                  <td>При auto устройство будет монтироваться автоматически при загрузке, или по команде mount. auto является вариантом по умолчанию. Если вы не хотите, чтобы устройство монтировалось автоматически, используйте параметр noauto.</td>
              </tr>
              <tr>
                  <td>defaults</td>
                  <td>Использовать настройки по умолчанию. Эквивалентно: rw,suid,dev,exec,auto,nouser,async.</td>
              </tr>
              <tr>
                  <td>exec / noexec</td>
                  <td>exec позволяет выполнять двоичные файлы, которые находятся на этом раздел, в то время как noexec не позволяет этого делать. noexec может быть полезно для раздела, который не содержит бинарные файлы например /var, или содержит бинарные файлы которые вы не хотите выполнять на вашей системе, или которые не могут быть выполнены в вашей системе.</td>
              </tr>
              <tr>
                  <td>encryption</td>
                  <td>Определяет используемый алгоритм шифрования. Используется в сочетании с опцией loop.</td>
              </tr>
              <tr>
                  <td>nofail</td>
                  <td>В случае отсутствия устройства не сообщать об ошибке.</td>
              </tr>
              <tr>
                  <td>_netdev</td>
                  <td>Используется для предотвращения попыток смонтировать файловые системы, подключённые к сети.</td>
              </tr>
              <tr>
                  <td>owner</td>
                  <td>Разрешает обычному (т.е. не root) пользователю монтировать файловую систему, если он является владельцем устройства. Эта опция подразумевает параметры nosuid и nodev.</td>
              </tr>
              <tr>
                  <td>ro</td>
                  <td>Монтировать только для чтения.</td>
              </tr>
              <tr>
                  <td>rw</td>
                  <td>Монтирование файловой системы для чтения и записи.</td>
              </tr>
              <tr>
                  <td>suid / nosuid</td>
                  <td>Разрешает использование битовых идентификаторов пользователей или групп / Запрещает использование битовых идентификаторов пользователей или групп.</td>
              </tr>
              <tr>
                  <td>user / nouser</td>
                  <td>user - разрешает монтирование от лица обычного пользователя, по умолчанию это имеет право сделать только root. nouser — соответсвенно запрещает.</td>
              </tr>
              <tr>
                  <td>dev / nodev</td>
                  <td>Интерпретировать/не интерпретировать блок специальных устройств на файловой системе.</td>
              </tr>
          </table>
      
          <p>Чаще всего при монтировании блочных устройств вам потребуется ключ defaults, а при монтировании сетевых ресурсов - user,noauto.</p>
          <p>Параметры dump и pass практически всегда будут ноль.</p>
      
          <h4>Параметр dump</h4>
          <p>Используется утилитой dump(8) для определения того, нужно ли создать резервную копию данных в файловой системе. У большинства пользователей утилита dump не установлена, поэтому им следует указывать 0 в этом поле.</p>
      
          <h4>Параметр fsck</h4>
          <p>Используется программой fsck для определения того, нужно ли проверять целостность файловой системы. Значение 1 следует указывать только для корневой файловой системы; для остальных ФС, которые вы хотите проверять, используйте значение 2, которое имеет менее высокий приоритет. Файловые системы, для которых в поле указано значение 0, не будут проверяться fsck.</p>
      
          <h3>Работа с графической утилитой gparted</h3>
          <p>Сложно работать с консольными утилитами? Есть вариант, как можно выполнить разметку диска с помощью графической утилиты gparted.</p>
          <p>Давайте попробуем с помощью данной программы:</p>
          <ul>
              <li>Удалить раздел, который уже есть в системе;</li>
              <li>Создать новый и разметить его.</li>
          </ul>
          <p>Приступим к работе:</p>
          <p>Откройте меню Пуск --> Системные --> Редактор разделов Gparted.</p>
      
          <img src="./Screen30.png" alt="Картинка">
      
          <p>Программа ожидаемо затребует у вас права администратора, введите пароль.</p>
      
          <img src="./Screen31.png" alt="Картинка">
      
          <p>По результату, вы получите сведения о разделах вашей операционной системы.</p>
          <p><strong>Но где же здесь разметка для диска /dev/sdb? Почему мы видим только разметку /dev/sda?</strong></p>
          <p>Все просто, в правом верхнем углу выберите необходимое устройство, в нашем случае это /dev/sdb.</p>
      
          <img src="./Screen32.png" alt="Картинка">
      
          <p><strong>Запомните! Вне зависимости от того, какой инструмент разметки вы используете - проводить такие работы нельзя с подключенным к каталогу устройством!</strong></p>
          <p>Поэтому, первым делом выполним размонтирование. Кликните ПКМ по разделу и выберите "Размонтировать".</p>
      
          <img src="./Screen33.png" alt="Картинка">
      
          <p>Затем, удалите раздел.</p>
      
          <img src="./Screen34.png" alt="Картинка">
      
          <p><strong>Неужели вот так просто мы удалили безвозвратно целый раздел?</strong></p>
          <p>Параметры в gparted не применяться, пока вы не запустите их. Наши изменения в данный момент - лишь показательные.</p>
          <p>Выберите "Новый", чтобы создать новый раздел.</p>
      
          <img src="./Screen35.png" alt="Картинка">
      
          <p>При выборе пункта "Новый" вы получаете возможность выбрать объем раздела, его тип и файловую систему - например, xfs.</p>
          <p>Попробуем разделить диск пополам, один на файловой системе XFS, а другой на EXT4.</p>
      
          <img src="./Screen36.png" alt="Картинка">
      
          <p>Как можно заметить, теперь у нас диск разделен на две отдельных области хранения созданных.</p>
      
          <img src="./Screen37.png" alt="Картинка">
      
          <p>Разметку второго раздела выполните самостоятельно. Сравните с результатом на скриншоте.</p>
      
          <img src="./Screen38.png" alt="Картинка">
      
          <p>Чтобы применить настройки - нажмите соответствующую кнопку в интерфейсе программы.</p>
      
          <img src="./Screen39.png" alt="Картинка">
      
          <p>Результат видно в gparted.</p>
      
          <img src="./Screen40.png" alt="Картинка">
      
          <p>Безусловно, теперь наши правила в /etc/fstab не подойдут, адаптировать их нужно так:</p>
          <pre><code>/dev/sdb1 /disk1 xfs defaults 0 0</code></pre>
          <pre><code>/dev/sdb2 /disk2 ext4 defaults 0 0</code></pre>
          <p>Итоговый результат выглядит так:</p>
      
          <img src="./Screen41.png" alt="Картинка">
      
          <h2>Дополнительная информация о файловых системах Astra Linux</h2>
          <p>В зависимости от выбора, сделанного в процессе установки, каталоги могут относиться к различным файловым системам. После начальной установки ФС ОС может состоять, например, из следующих частей:</p>
          <ul>
              <li><strong>root:</strong></li>
              <li><strong>/bin</strong> — находятся выполняемые программы (точнее, их двоичные файлы). Они необходимы для работы системы. Многие команды ОС являются программами из этого каталога;</li>
              <li><strong>/dev</strong> — расположены особые файлы, называемые «файлами устройств» (device files). С их помощью осуществляется доступ ко всем физическим устройствам, установленным в системе;</li>
              <li><strong>/boot</strong> — содержит необходимую информацию для загрузки системы (ядро (ядра), образ initrd, файлы загрузчика);</li>
              <li><strong>/root</strong> — домашний каталог суперпользователя;</li>
              <li><strong>/tmp</strong> — используется для хранения временных файлов, создаваемых программами в процессе своей работы. Работая с программами, создающими много больших временных файлов, лучше иметь отдельную ФС, чем простой каталог корневой ФС;</li>
              <li><strong>/etc</strong> — содержит конфигурационные файлы ОС. Здесь находится файл паролей passwd, а также список ФС, подключаемых при начальной загрузке fstab. В этом же каталоге хранятся сценарии загрузки (startup scripts), список узлов (hosts) с их IP-адресами и множество других данных о конфигурации;</li>
              <li><strong>/lib</strong> — содержатся разделяемые библиотеки, используемые многими программами во время своей работы. Применяя разделяемые библиотеки, хранящиеся в общедоступном месте, можно уменьшить размер программ за счет повторного использования одного и того же кода;</li>
              <li><strong>/рrос</strong> — является виртуальной файловой системой и используется для чтения из памяти информации о системе;</li>
              <li><strong>/sbin</strong> — хранятся системные двоичные файлы (большинство из них используется для нужд системного администрирования);</li>
              <li><strong>/usr</strong> — хранятся различные программы и данные, не подлежащие изменению. Каталог /usr и его подкаталоги необходимы для функционирования ОС, т. к. содержат наиболее важные программы. Данный каталог почти всегда является отдельной ФС;</li>
              <li><strong>/var</strong> — содержатся изменяемые файлы (такие как log-файлы и др.);</li>
              <li><strong>/home</strong> — состоит из личных каталогов пользователей. Общепринято иметь здесь отдельный раздел диска и файловой системы, чтобы обеспечить пользователям достаточное пространство для размещения своих файлов, а также возможность быстро его расширять.</li>
          </ul>
      
          <h2>Практическая работа</h2>
          <ol>
              <li>Загрузите модуль для управления Bluetooth-адаптером, а также модуль для WiFi-адаптера с использованием драйвера iwlwifi.</li>
              <li>Запретите загружать модуль r8169, через astra-blacklist.conf.</li>
          </ol>
      
          <p>В следующем материале вы познакомитесь с Расширенным администрированием устройств хранения данных!</p>
          <p>Благодарю за чтение и успехов вам в обучении!</p>
      
          <h2>Дополнительная информация:</h2>
          <ol>
              <li>Руководство администратора AstraLinux Часть 1 <a href="https://astralinux.ru/products/astra-linux-special-edition/relizyi/smolensk/dokumentacziya/rukovodstvo-administratora-chast-1-astra-se.pdf">Ссылка</a></li>
              <li>Про Fstab <a href="https://wiki.archlinux.org/title/Fstab_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)">Ссылка</a></li>
              <li>Про Fdisk <a href="https://linux-faq.ru/page/komanda-fdisk">Ссылка</a></li>
          </ol>
            </ul>
          </div>
        </div>
      </div>
    </article>              
  
  </p>
</footer>


    </main>
  </div>
</div>


      

    
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js" integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js" integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>

      

      
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin="anonymous"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/r.min.js"></script>
        
      

    

    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.5.1/leaflet.js" integrity="sha256-EErZamuLefUnbMBQbsEqu1USa+btR2oIlCpBJbyD4/g=" crossorigin="anonymous"></script>
    

    
    
    <script>const code_highlighting = true;</script>
    

    
    
    <script>const isSiteThemeDark = false;</script>
    

    
    
    
    
    
    
    <script>
      const search_config = {"indexURI":"/index.json","minLength":1,"threshold":0.3};
      const i18n = {"no_results":"No results found","placeholder":"Search...","results":"results found"};
      const content_type = {
        'post': "Posts",
        'project': "Projects",
        'publication' : "Publications",
        'talk' : "Talks"
        };
    </script>
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.1/anchor.min.js" integrity="sha256-pB/deHc9CGfFpJRjC43imB29Rse8tak+5eXqntO94ck=" crossorigin="anonymous"></script>
    <script>
      anchors.add();
    </script>
    

    
    
    <script id="search-hit-fuse-template" type="text/x-template">
      <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
      </div>
    </script>
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>
    

    
    

    
    

    
    

    
    
    
    
    
    
    
    
    
      
    
    
    
    
    <script src="/js/academic.min.4aaf2d64e50f8e54cf66dcc54147a22e.js"></script>

    






  
  

  
<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Cite</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <pre><code class="tex hljs"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank">
          <i class="fas fa-copy"></i> Copy
        </a>
        <a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank">
          <i class="fas fa-download"></i> Download
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

</body>
</html>
